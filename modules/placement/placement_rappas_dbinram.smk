"""
This module makes placements with RAPPAS
Note: this module expect AR to be already computed
"""

__author__ = "Benjamin Linard, Nikolai Romashchenko"
__license__ = "MIT"


from pewo.templates import get_jplace_output_template, \
                           get_log_output_template


def get_rappas_input_reads(pruning):
    """
    Creates a list of input reads files. For generated reads from a pruning,
    all read lengths are passed in a single RAPPAS execution.
    Read lengths can not be wildcards and must be set manually
    """
    # reads are taken from the input
    if "dataset_reads" in config:
        return [config["workdir"] + "/R+/{query}.fasta"]
    # reads are generated by pruning the input tree
    else:
        return [config["workdir"] + "/R/" + pruning + "_r" + str(length) + ".fasta"
                for length in config["read_length"]]


rule db_build_in_ram_rappas:
    """
    Build a RAPPAS database in RAM.
    """
    input:
        a = config["workdir"]+"/A/{pruning}.align",
        t = config["workdir"]+"/T/{pruning}.tree",
        r = lambda wildcards: get_rappas_input_reads(wildcards.pruning),
        ar = lambda wildcards: expected_ar_outputs(wildcards.arsoft)
    output:
        get_jplace_output_template(config, PlacementSoftware.RAPPAS)
    log:
        get_log_output_template(config, PlacementSoftware.RAPPAS)
        #config["workdir"] + "/logs/placement_rappas/" + get_log_template(PlacementSoftware.RAPPAS)
    version: "1.00"
    params:
        states=["nucl"] if config["states"]==0 else ["amino"],
        ardir=config["workdir"]+"/RAPPAS/{pruning}/red{reduction}_ar{arsoft}/AR",
        workdir=config["workdir"]+"/RAPPAS/{pruning}/red{reduction}_ar{arsoft}/k{k}_o{omega}",
        dbfilename="DB.bin",
        querystring=lambda wildcards, input : ",".join(input.r),
        maxp=config["maxplacements"],
        minlwr=config["minlwr"],
        arbin=lambda wildcards: select_arbin(wildcards.arsoft)
    run:
        shell(
            "java -Xms2G -Xmx"+str(config["config_rappas"]["memory"])+"G -jar $(which RAPPAS.jar) -p b "
            "-b $(which {params.arbin}) "
            "-k {wildcards.k} --omega {wildcards.omega} -t {input.t} -r {input.a} -q {params.querystring} "
            "-w {params.workdir} --ardir {params.ardir} -s {params.states} --ratio-reduction {wildcards.reduction} "
            "--keep-at-most {params.maxp} --keep-factor {params.minlwr} "
            "--use_unrooted --dbinram --dbfilename {params.dbfilename} &> {log} "
        )

        # TODO: Generalize this.
        # The same name conventions are listed in get_jplace_output_template.
        # Hint: pass the 'wildcard=True' to template generation functions to produce {wildcard.arg}-
        # and {arg}-like templates by the same function.
        #
        # Reads are taken from the input
        if "dataset_reads" in config:
            shell(
                "mv {params.workdir}/placements_{wildcards.query}.fasta.jplace "
                "{params.workdir}/{wildcards.query}_k{wildcards.k}_o{wildcards.omega}_red{wildcards.reduction}_ar{wildcards.arsoft}_rappas.jplace"
            )
        # Reads are generated by pruning the input tree
        else:
            for length in config["read_length"]:
                shell(
                    "mv {params.workdir}/placements_{wildcards.pruning}_r" + str(length) + ".fasta.jplace "
                    "{params.workdir}/{wildcards.pruning}_r"+str(length)+"_k{wildcards.k}_o{wildcards.omega}_red{wildcards.reduction}_ar{wildcards.arsoft}_rappas.jplace "
                )
